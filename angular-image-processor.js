// Generated by CoffeeScript 1.9.1
(function() {
  angular.module('tbImageProcessor', []).service('imageProcessor', function($q, $rootScope) {
    return {
      startTime: 0,
      lastTime: 0,
      _logTime: function(methName) {
        var logger;
        logger = typeof forge !== "undefined" && forge !== null ? forge.logging : console;
        this.lastTime = Date.now();
        return logger.log("@imageProcessor[" + this.lastTime + "]: " + methName + " (" + (this.lastTime - this.startTime) + ")");
      },

      /*
       Transform canvas coordination according to specified frame size and orientation
       Orientation value is from EXIF tag
       */
      _transformCoordinate: function(canvas, width, height, orientation) {
        var ctx;
        if (orientation >= 5) {
          canvas.width = height;
          canvas.height = width;
        } else {
          canvas.width = width;
          canvas.height = height;
        }
        ctx = canvas.getContext("2d");
        switch (orientation) {
          case 2:
            ctx.translate(width, 0);
            return ctx.scale(-1, 1);
          case 3:
            ctx.translate(width, height);
            return ctx.rotate(Math.PI);
          case 4:
            ctx.translate(0, height);
            return ctx.scale(1, -1);
          case 5:
            ctx.rotate(0.5 * Math.PI);
            return ctx.scale(1, -1);
          case 6:
            ctx.rotate(0.5 * Math.PI);
            return ctx.translate(0, -height);
          case 7:
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(width, -height);
            return ctx.scale(-1, 1);
          case 8:
            ctx.rotate(-0.5 * Math.PI);
            return ctx.translate(-width, 0);
        }
      },

      /*
       Detecting vertical squash in loaded image.
       Fixes a bug which squash image vertically while drawing into canvas for some images.
       This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
       */
      _detectVerticalSquash: function(img) {
        var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
        canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = ih;
        ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        data = ctx.getImageData(0, 0, 1, ih).data;
        sy = 0;
        ey = ih;
        py = ih;
        while (py > sy) {
          alpha = data[(py - 1) * 4 + 3];
          if (alpha === 0) {
            ey = py;
          } else {
            sy = py;
          }
          py = (ey + sy) >> 1;
        }
        ratio = py / ih;
        if (ratio === 0) {
          return 1;
        } else {
          return ratio;
        }
      },

      /*
       A replacement for context.drawImage
       (args are for source and destination).
       */
      _drawImageIOSFix: function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
        var vertSquashRatio;
        this._logTime("detectVerticalSquash");
        vertSquashRatio = this._detectVerticalSquash(img);
        this._logTime("drawImage");
        ctx.drawImage(img, sx * vertSquashRatio, sy * vertSquashRatio, sw * vertSquashRatio, sh * vertSquashRatio, dx, dy, dw, dh);
      },
      _getResizeArea: function() {
        var resizeArea, resizeAreaId;
        resizeAreaId = "fileupload-resize-area";
        resizeArea = document.getElementById(resizeAreaId);
        if (!resizeArea) {
          resizeArea = document.createElement("canvas");
          resizeArea.id = resizeAreaId;
          resizeArea.style.visibility = "hidden";
          document.body.appendChild(resizeArea);
        }
        return resizeArea;
      },
      _scaleImage: function(origImage, config) {
        var origAR, sourceDims, targetAR;
        sourceDims = {
          width: 0,
          height: 0,
          left: 0,
          top: 0,
          fScaleToTargetWidth: true
        };
        targetAR = config.width / config.height;
        origAR = config.orientation >= 5 ? origImage.height / origImage.width : origImage.width / origImage.height;
        this._logTime("AR: target=" + targetAR + " origAR=" + origAR + " origWidth=" + origImage.width + " origHeight=" + origImage.height);
        sourceDims.fScaleOnWidth = targetAR > origAR;
        if (sourceDims.fScaleOnWidth) {
          sourceDims.width = origImage.width;
          sourceDims.height = Math.floor(config.orientation >= 5 ? targetAR * origImage.width : 1 / targetAR * origImage.width);
        } else {
          sourceDims.width = Math.floor(config.orientation >= 5 ? 1 / targetAR * origImage.height : targetAR * origImage.height);
          sourceDims.height = origImage.height;
        }
        sourceDims.left = Math.floor((origImage.width - sourceDims.width) / 2);
        sourceDims.top = Math.floor((origImage.height - sourceDims.height) / 2);
        return sourceDims;
      },
      _doResizeImage: function(origImage, config) {
        var canvas, ctx, dataURL, sourceDims, type;
        type = 'image/jpeg';
        canvas = this._getResizeArea();
        canvas.width = config.width;
        canvas.height = config.height;
        sourceDims = this._scaleImage(origImage, config);
        ctx = canvas.getContext("2d");
        this._logTime("transformCoordinate");
        this._transformCoordinate(canvas, config.width, config.height, config.orientation);
        this._logTime("drawImageIOSFix");
        this._drawImageIOSFix(ctx, origImage, sourceDims.left, sourceDims.top, sourceDims.width, sourceDims.height, 0, 0, config.width, config.height);
        this._logTime("drawImageIOSFixComplete");
        dataURL = canvas.toDataURL(type, config.quality);
        this._logTime("dataURLGenerated");
        return dataURL;
      },
      _createImage: function(url, callback) {
        var image;
        this._logTime("_createImage");
        image = new Image();
        image.onload = function() {
          return callback(image);
        };
        return image.src = url;
      },
      createImageAndConfig: function(url, options, callback) {
        var me, parseVersions;
        me = this;
        parseVersions = function(image, options, orientation) {
          var arOptions, chosenAR, origAR, ref, ref1, versions;
          me._logTime("parseVersions");
          versions = [
            {
              width: (ref = options.width) != null ? ref : 150,
              height: (ref1 = options.height) != null ? ref1 : 150
            }
          ];
          if (!_.isEmpty(options.aspectRatios)) {
            arOptions = _(options.aspectRatios).map(function(ratio) {
              return ratio.split(':');
            }).map(function(ratio) {
              var h, w;
              w = parseInt(ratio[0]);
              h = parseInt(ratio[1]);
              return w / h;
            }).value();
            origAR = orientation >= 5 ? image.height / image.width : image.width / image.height;
            chosenAR = _.reduce(_.tail(arOptions), function(closest, option) {
              if (Math.abs(option - origAR) < Math.abs(closest - origAR)) {
                return option;
              } else {
                return closest;
              }
            }, _.head(arOptions));
            versions = _.map(options.maxWidths, function(maxWidth) {
              if (chosenAR > 1) {
                return {
                  maxWidth: maxWidth,
                  width: maxWidth,
                  height: 1 / chosenAR * maxWidth
                };
              } else {
                return {
                  maxWidth: maxWidth,
                  width: chosenAR * maxWidth,
                  height: maxWidth
                };
              }
            });
          }
          return versions;
        };
        return this._createImage(url, (function(_this) {
          return function(image) {
            _this._logTime("getEXIF");
            return EXIF.getData(image, function() {
              var orientation, versions;
              orientation = EXIF.getTag(this, "Orientation");
              me._logTime("orientation=" + orientation);
              versions = parseVersions(image, options, orientation);
              return _.each(versions, function(version) {
                var ref;
                return callback(image, _.extend(version, {
                  quality: (ref = options.quality) != null ? ref : 0.7,
                  orientation: orientation
                }));
              });
            });
          };
        })(this));
      },
      processImage: function(image, config, onVersionStart, onVersionComplete) {
        var dataURL, fromIdx, mimeType, rawExt, resizedImage, toIdx;
        onVersionStart(config.maxWidth, config);
        dataURL = this._doResizeImage(image, config);
        this._logTime("afterResizeImage");
        fromIdx = dataURL.indexOf(':');
        toIdx = dataURL.indexOf(';', fromIdx);
        mimeType = dataURL.substring(fromIdx + 1, toIdx);
        rawExt = mimeType.split('/').pop();
        resizedImage = _.extend(config, {
          dataURL: dataURL,
          type: mimeType,
          ext: rawExt === 'jpeg' ? 'jpg' : 'png'
        });
        this._logTime("onVersionComplete");
        return onVersionComplete(config.maxWidth, resizedImage);
      },

      /*
       URL to use in an image element
       options: {
       height or 300
       width or 250
       quality or 0.7
       }
       callback -> callback that is sent the resized dataURL and mime type
       */
      run: function(url, options, onVersionStart, onVersionComplete) {
        this.startTime = Date.now();
        this._logTime("run(" + url);
        return this.createImageAndConfig(url, options, (function(_this) {
          return function(image, config) {
            return _this.processImage(image, config, onVersionStart, onVersionComplete);
          };
        })(this));
      }
    };
  });

}).call(this);

//# sourceMappingURL=angular-image-processor.js.map
