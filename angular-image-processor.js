// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('tbImageProcessor', []).service('imageProcessor', function($q) {
    return {
      startTime: 0,
      lastTime: 0,
      logTime: function(methName) {
        return this.lastTime = Date.now();
      },

      /*
      Transform canvas coordination according to specified frame size and orientation
      Orientation value is from EXIF tag
       */
      transformCoordinate: function(canvas, width, height, orientation) {
        var ctx;
        switch (orientation) {
          case 5:
          case 6:
          case 7:
          case 8:
            canvas.width = height;
            canvas.height = width;
            break;
          default:
            canvas.width = width;
            canvas.height = height;
        }
        ctx = canvas.getContext("2d");
        switch (orientation) {
          case 2:
            ctx.translate(width, 0);
            return ctx.scale(-1, 1);
          case 3:
            ctx.translate(width, height);
            return ctx.rotate(Math.PI);
          case 4:
            ctx.translate(0, height);
            return ctx.scale(1, -1);
          case 5:
            ctx.rotate(0.5 * Math.PI);
            return ctx.scale(1, -1);
          case 6:
            ctx.rotate(0.5 * Math.PI);
            return ctx.translate(0, -height);
          case 7:
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(width, -height);
            return ctx.scale(-1, 1);
          case 8:
            ctx.rotate(-0.5 * Math.PI);
            return ctx.translate(-width, 0);
        }
      },

      /*
      Detecting vertical squash in loaded image.
      Fixes a bug which squash image vertically while drawing into canvas for some images.
      This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
       */
      detectVerticalSquash: function(img) {
        var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
        canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = ih;
        ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        data = ctx.getImageData(0, 0, 1, ih).data;
        sy = 0;
        ey = ih;
        py = ih;
        while (py > sy) {
          alpha = data[(py - 1) * 4 + 3];
          if (alpha === 0) {
            ey = py;
          } else {
            sy = py;
          }
          py = (ey + sy) >> 1;
        }
        ratio = py / ih;
        if (ratio === 0) {
          return 1;
        } else {
          return ratio;
        }
      },

      /*
      A replacement for context.drawImage
      (args are for source and destination).
       */
      drawImageIOSFix: function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
        var vertSquashRatio;
        this.logTime("detectVerticalSquash");
        vertSquashRatio = this.detectVerticalSquash(img);
        this.logTime("drawImage");
        ctx.drawImage(img, sx * vertSquashRatio, sy * vertSquashRatio, sw * vertSquashRatio, sh * vertSquashRatio, dx, dy, dw, dh);
      },
      getResizeArea: function() {
        var resizeArea, resizeAreaId;
        resizeAreaId = "fileupload-resize-area";
        resizeArea = document.getElementById(resizeAreaId);
        if (!resizeArea) {
          resizeArea = document.createElement("canvas");
          resizeArea.id = resizeAreaId;
          resizeArea.style.visibility = "hidden";
          document.body.appendChild(resizeArea);
        }
        return resizeArea;
      },
      resizeImage: function(origImage, config) {
        var canvas, deferred, origHeight, origWidth, sourceHeight, sourceWidth, sourceX, sourceY, type;
        deferred = $q.defer();
        type = 'image/jpeg';
        canvas = this.getResizeArea();
        canvas.width = config.maxWidth;
        canvas.height = config.maxHeight;
        origWidth = origImage.width;
        origHeight = origImage.height;
        sourceWidth = void 0;
        sourceHeight = void 0;
        sourceX = void 0;
        sourceY = void 0;
        if (origWidth < origHeight) {
          sourceWidth = origWidth;
          sourceX = 0;
          sourceHeight = origWidth;
          sourceY = (origHeight - origWidth) / 2;
        } else {
          sourceWidth = origHeight;
          sourceX = (origWidth - origHeight) / 2;
          sourceHeight = origHeight;
          sourceY = 0;
        }
        EXIF.getData(origImage, (function(_this) {
          return function() {
            var ctx, dataURL, orientation;
            orientation = EXIF.getTag(_this, "Orientation");
            ctx = canvas.getContext("2d");
            _this.logTime("transformCoordinate");
            _this.transformCoordinate(canvas, config.maxWidth, config.maxHeight, orientation);
            _this.logTime("drawImageIOSFix");
            _this.drawImageIOSFix(ctx, origImage, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, config.maxWidth, config.maxHeight);
            _this.logTime("drawImageIOSFixComplete");
            dataURL = canvas.toDataURL(type, config.quality);
            _this.logTime("dataURLGenerated");
            deferred.resolve(dataURL);
          };
        })(this));
        return deferred.promise;
      },
      createImage: function(url, callback) {
        var image;
        this.logTime("createImage");
        image = new Image();
        image.onload = function() {
          return callback(image);
        };
        return image.src = url;
      },
      doResizing: function(url, options, callback) {
        return this.createImage(url, (function(_this) {
          return function(image) {
            var config, _ref, _ref1, _ref2;
            _this.logTime("preResizeImage");
            config = {
              maxHeight: (_ref = options.resizeMaxHeight) != null ? _ref : 300,
              maxWidth: (_ref1 = options.resizeMaxWidth) != null ? _ref1 : 250,
              quality: (_ref2 = options.resizeQuality) != null ? _ref2 : 0.7
            };
            return _this.resizeImage(image, config).then(function(dataURL) {
              var aspect, fromIdx, mimeType, rawExt, resizedImage, toIdx;
              _this.logTime("postResizeImage");
              fromIdx = dataURL.indexOf(':');
              toIdx = dataURL.indexOf(';', fromIdx);
              mimeType = dataURL.substring(fromIdx + 1, toIdx);
              rawExt = mimeType.split('/').pop();
              aspect = config.maxHeight === config.maxWidth ? 'square' : config.maxHeight > config.maxWidth ? 'portrait' : 'landscape';
              resizedImage = {
                dataURL: dataURL,
                type: mimeType,
                ext: rawExt === 'jpeg' ? 'jpg' : 'png',
                aspect: aspect
              };
              _this.logTime("callback");
              return callback(resizedImage);
            });
          };
        })(this));
      },

      /*
        URL to use in an image element
        options: {
            resizeMaxHeight or 300
            resizeMaxWidth or 250
            resizeQuality or 0.7
            resizeType: currently ignored and hard coded to jpg
        }
        callback -> callback that is sent the resized dataURL and mime type
       */
      run: function(url, options, callback) {
        this.startTime = Date.now();
        return this.doResizing(url, options, callback);
      }
    };
  });

}).call(this);

//# sourceMappingURL=angular-image-processor.map
