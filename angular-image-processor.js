// Generated by CoffeeScript 1.7.1
(function() {
  angular.module('tbImageProcessor', []).service('imageProcessor', function($q, $rootScope) {
    return {
      startTime: 0,
      lastTime: 0,
      _logTime: function(methName) {
        return this.lastTime = Date.now();
      },

      /*
      Transform canvas coordination according to specified frame size and orientation
      Orientation value is from EXIF tag
       */
      _transformCoordinate: function(canvas, width, height, orientation) {
        var ctx;
        switch (orientation) {
          case 5:
          case 6:
          case 7:
          case 8:
            canvas.width = height;
            canvas.height = width;
            break;
          default:
            canvas.width = width;
            canvas.height = height;
        }
        ctx = canvas.getContext("2d");
        switch (orientation) {
          case 2:
            ctx.translate(width, 0);
            return ctx.scale(-1, 1);
          case 3:
            ctx.translate(width, height);
            return ctx.rotate(Math.PI);
          case 4:
            ctx.translate(0, height);
            return ctx.scale(1, -1);
          case 5:
            ctx.rotate(0.5 * Math.PI);
            return ctx.scale(1, -1);
          case 6:
            ctx.rotate(0.5 * Math.PI);
            return ctx.translate(0, -height);
          case 7:
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(width, -height);
            return ctx.scale(-1, 1);
          case 8:
            ctx.rotate(-0.5 * Math.PI);
            return ctx.translate(-width, 0);
        }
      },

      /*
      Detecting vertical squash in loaded image.
      Fixes a bug which squash image vertically while drawing into canvas for some images.
      This is a bug in iOS6 devices. This function from https://github.com/stomita/ios-imagefile-megapixel
       */
      _detectVerticalSquash: function(img) {
        var alpha, canvas, ctx, data, ey, ih, iw, py, ratio, sy;
        iw = img.naturalWidth;
        ih = img.naturalHeight;
        canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = ih;
        ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);
        data = ctx.getImageData(0, 0, 1, ih).data;
        sy = 0;
        ey = ih;
        py = ih;
        while (py > sy) {
          alpha = data[(py - 1) * 4 + 3];
          if (alpha === 0) {
            ey = py;
          } else {
            sy = py;
          }
          py = (ey + sy) >> 1;
        }
        ratio = py / ih;
        if (ratio === 0) {
          return 1;
        } else {
          return ratio;
        }
      },

      /*
      A replacement for context.drawImage
      (args are for source and destination).
       */
      _drawImageIOSFix: function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
        var vertSquashRatio;
        this._logTime("detectVerticalSquash");
        vertSquashRatio = this._detectVerticalSquash(img);
        this._logTime("drawImage");
        ctx.drawImage(img, sx * vertSquashRatio, sy * vertSquashRatio, sw * vertSquashRatio, sh * vertSquashRatio, dx, dy, dw, dh);
      },
      _getResizeArea: function() {
        var resizeArea, resizeAreaId;
        resizeAreaId = "fileupload-resize-area";
        resizeArea = document.getElementById(resizeAreaId);
        if (!resizeArea) {
          resizeArea = document.createElement("canvas");
          resizeArea.id = resizeAreaId;
          resizeArea.style.visibility = "hidden";
          document.body.appendChild(resizeArea);
        }
        return resizeArea;
      },
      _scaleImage: function(origImage, config) {
        var origAR, sourceDims, targetAR;
        sourceDims = {
          width: 0,
          height: 0,
          left: 0,
          top: 0,
          fScaleToTargetWidth: true
        };
        targetAR = config.width / config.height;
        origAR = origImage.width / origImage.height;
        sourceDims.fScaleOnWidth = targetAR > origAR;
        if (sourceDims.fScaleOnWidth) {
          sourceDims.width = origImage.width;
          sourceDims.height = Math.floor(1 / targetAR * origImage.width);
        } else {
          sourceDims.width = Math.floor(targetAR * origImage.height);
          sourceDims.height = origImage.height;
        }
        sourceDims.left = Math.floor((origImage.width - sourceDims.width) / 2);
        sourceDims.top = Math.floor((origImage.height - sourceDims.height) / 2);
        return sourceDims;
      },
      _doResizeImage: function(origImage, config) {
        var canvas, deferred, sourceDims, type;
        deferred = $q.defer();
        type = 'image/jpeg';
        canvas = this._getResizeArea();
        canvas.width = config.width;
        canvas.height = config.height;
        sourceDims = this._scaleImage(origImage, config);
        EXIF.getData(origImage, (function(_this) {
          return function() {
            var ctx, dataURL, orientation;
            orientation = EXIF.getTag(_this, "Orientation");
            ctx = canvas.getContext("2d");
            _this._logTime("transformCoordinate");
            _this._transformCoordinate(canvas, config.width, config.height, orientation);
            _this._logTime("drawImageIOSFix");
            _this._drawImageIOSFix(ctx, origImage, sourceDims.left, sourceDims.top, sourceDims.width, sourceDims.height, 0, 0, config.width, config.height);
            _this._logTime("drawImageIOSFixComplete");
            dataURL = canvas.toDataURL(type, config.quality);
            _this._logTime("dataURLGenerated");
            deferred.resolve(dataURL);
          };
        })(this));
        return deferred.promise;
      },
      _createImage: function(url, callback) {
        var image;
        this._logTime("_createImage");
        image = new Image();
        image.onload = function() {
          return callback(image);
        };
        return image.src = url;
      },
      _parseVersions: function(image, options) {
        var arOptions, chosenAR, origAR, versions, _ref, _ref1;
        versions = [
          {
            width: (_ref = options.width) != null ? _ref : 150,
            height: (_ref1 = options.height) != null ? _ref1 : 150
          }
        ];
        if (!_.isEmpty(options.aspectRatios)) {
          arOptions = _(options.aspectRatios).map(function(ratio) {
            return ratio.split(':');
          }).map(function(ratio) {
            var h, w;
            w = parseInt(ratio[0]);
            h = parseInt(ratio[1]);
            return w / h;
          }).value();
          origAR = image.width / image.height;
          chosenAR = _.reduce(_.tail(arOptions), function(closest, option) {
            if (Math.abs(option - origAR) < Math.abs(closest - origAR)) {
              return option;
            } else {
              return closest;
            }
          }, _.head(arOptions));
          versions = _.map(options.maxWidths, function(maxWidth) {
            if (chosenAR > 1) {
              return {
                maxWidth: maxWidth,
                width: maxWidth,
                height: 1 / chosenAR * maxWidth
              };
            } else {
              return {
                maxWidth: maxWidth,
                width: chosenAR * maxWidth,
                height: maxWidth
              };
            }
          });
        }
        return versions;
      },
      createImageAndConfig: function(url, options, callback) {
        return this._createImage(url, (function(_this) {
          return function(image) {
            var versions;
            _this._logTime("parseVersions");
            versions = _this._parseVersions(image, options);
            return _.each(versions, function(version) {
              var _ref;
              return callback(image, _.extend(version, {
                quality: (_ref = options.quality) != null ? _ref : 0.7
              }));
            });
          };
        })(this));
      },
      processImage: function(image, config, onVersionStart, onVersionComplete) {
        $rootScope.$apply(function() {
          return onVersionStart(config.maxWidth, config);
        });
        return this._doResizeImage(image, config).then((function(_this) {
          return function(dataURL) {
            var fromIdx, mimeType, rawExt, resizedImage, toIdx;
            _this._logTime("postResizeImage");
            fromIdx = dataURL.indexOf(':');
            toIdx = dataURL.indexOf(';', fromIdx);
            mimeType = dataURL.substring(fromIdx + 1, toIdx);
            rawExt = mimeType.split('/').pop();
            resizedImage = _.extend(config, {
              dataURL: dataURL,
              type: mimeType,
              ext: rawExt === 'jpeg' ? 'jpg' : 'png'
            });
            _this._logTime("callback");
            return onVersionComplete(config.maxWidth, resizedImage);
          };
        })(this));
      },

      /*
        URL to use in an image element
        options: {
            height or 300
            width or 250
            quality or 0.7
        }
        callback -> callback that is sent the resized dataURL and mime type
       */
      run: function(url, options, onVersionStart, onVersionComplete) {
        this.startTime = Date.now();
        return this.createImageAndConfig(url, options, (function(_this) {
          return function(image, config) {
            return _this.processImage(image, config, onVersionStart, onVersionComplete);
          };
        })(this));
      }
    };
  });

}).call(this);

//# sourceMappingURL=angular-image-processor.map
